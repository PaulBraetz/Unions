using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

using System.Text;

var result = new StringBuilder(
    """
    // <auto-generated>
    // This file was generated using a tool. Manual changes could be overwritten at any point.
    // </auto-generated>

    namespace RhoMicro.Unions.Abstractions;

    using System;
    using System.Collections.Generic;

    /// <summary>
    /// Represents a superset union type.
    /// </summary>
    /// <typeparam name="TSubset">The subset union type that this union type is a superset of.</typeparam>
    /// <typeparam name="TSuperset">This type (akin to <c>TSelf</c>).</typeparam>
    public interface ISuperset<TSubset, TSuperset>
        where TSuperset : ISuperset<TSubset, TSuperset>
    {
        /// <summary>
        /// Implicitly converts an instance of the subset union type to this superset union type.
        /// </summary>
        /// <param name="subset">The subset union type instance to convert.</param>
        static abstract implicit operator TSuperset(TSubset subset);
        /// <summary>
        /// Explicitly converts an instance of this superset union type to the subset union type.
        /// </summary>
        /// <param name="superset">The superset union type instance to convert.</param>
        static abstract explicit operator TSubset(TSuperset superset);
    }
    /// <summary>
    /// Represents a union type that is able to be converted to a type.
    /// </summary>
    /// <typeparam name="TSelf">The union type.</typeparam>
    public interface IUnion<TSelf>
        where TSelf : IUnion<TSelf>
    {
        /// <summary>
        /// Gets the type reresented by this instance.
        /// </summary>
        Type RepresentedType { get; }
        /// <summary>
        /// Gets types of value this union type can represent.
        /// </summary>
        static IReadOnlyList<Type> RepresentableTypes { get; }
        /// <summary>
        /// Determines whether this instance is representing a value of type <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The type whose representation in this instance to determine.</typeparam>
        /// <returns><see langword="true"/> if this instance is representing a value of type <typeparamref name="T"/>; otherwise, <see langword="false"/>.</returns>
        Boolean Is<T>();
        /// <summary>
        /// Determines whether this instance is representing a value of the type provided.
        /// </summary>
        /// <param name="type">The type whose representation in this instance to determine.</param>
        /// <returns><see langword="true"/> if this instance is representing a value of the type provided; otherwise, <see langword="false"/>.</returns>
        Boolean Is(Type type);
        /// <summary>
        /// Attempts to get the value represented by this type as an instance of <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The type to retrieve this instances' value as.</typeparam>
        /// <returns>The value of this instance, if it is representing a value of type <typeparamref name="T"/>; otherwise, an exception of type <see cref="InvalidOperationException"/> will be thrown.</returns>
        T As<T>();
        /// <summary>
        /// Attempts to create a new instance of the union type using the value provided.
        /// </summary>
        /// <typeparam name="T">The type of value from which to create an instance of <typeparamref name="TSelf"/>.</typeparam>
        /// <param name="value">The value from which to create an instance of <typeparamref name="TSelf"/>.</param>
        /// <param name="instance">A new instance of <typeparamref name="TSelf"/> if one could be created using <paramref name="value"/>; otherwise, <see langword="default"/>.</param>
        /// <returns><see langword="true"/> if an instance of <typeparamref name="TSelf"/> could be created; otherwise, <see langword="false"/>.</returns>
        static abstract Boolean TryCreate<T>(T value, out TSelf instance);
        /// <summary>
        /// Creates a new instance of the union type using the value provided.
        /// </summary>
        /// <typeparam name="T">The type of value from which to create an instance of <typeparamref name="TSelf"/>.</typeparam>
        /// <param name="value">The value from which to create an instance of <typeparamref name="TSelf"/>.</param>
        /// <returns>A new instance of <typeparamref name="TSelf"/> if one could be created using <paramref name="value"/>; otherwise, an exception of type <see cref="ArgumentException"/> will be thrown.</returns>
        static abstract TSelf Create<T>(T value);
    }
    
    """
);
for(var i = 1; i < 33; i++)
{
    var indices = Enumerable.Range(1, i);
    var typeParameters = String.Join(',', indices.Select(i => $"T{i}"));
    var constraints = String.Join(",\n", indices.Select(i => $"\t\tISuperset<T{i}, TSuperset>"));
    var typeParamComments = String.Join("\n", indices.Select(i => $"/// <typeparam name=\"T{i}\">The {ordinalOf(i)} type unions of this type are able to represent.</typeparam>"));
    var actions = String.Join(',', indices.Select(i => $"Action<T{i}> onT{i}"));
    var actionParamComments = String.Join('\n', indices.Select(i => $"/// <param name=\"onT{i}\">The handler to invoke if the represented type is <typeparamref name=\"T{i}\"/>.</param>"));
    var projections = String.Join(',', indices.Select(i => $"Func<T{i}, TResult> onT{i}"));
    var projectionParamComments = String.Join('\n', indices.Select(i => $"/// <param name=\"onT{i}\">The projection to invoke if the represented type is <typeparamref name=\"T{i}\"/>.</param>"));

    var definition =
        $$"""
        /// <summary>
        /// Represents a union type that is able to represent {{i}} type{{(i > 1 ? "s" : String.Empty)}}
        /// </summary>
        {{typeParamComments}}
        /// <typeparam name="TSelf">The union type.</typeparam>
        public interface IUnion<TSelf, {{typeParameters}}> : IUnion<TSelf>
            where TSelf : IUnion<TSelf, {{typeParameters}}>
        {
            /// <summary>
            /// Safely converts this instance to a union type that is either a superset of or congruent to this one.
            /// </summary>
            /// <typeparam name="TSuperset">The type of union to convert this instance to.</typeparam>
            /// <returns>This instance converted to an instance of <typeparamref name="TSuperset"/>.</returns>
            TSuperset DownCast<TSuperset>()
            where TSuperset : 
            IUnion<TSuperset, {{typeParameters}}>;
            /// <summary>
            /// Invokes a handler based on the type of value being represented.
            /// </summary>
            {{actionParamComments}}
            void Switch({{actions}});
            /// <summary>
            /// Invokes a projection based on the type of value being represented.
            /// </summary>
            {{projectionParamComments}}
            /// <returns>The projected value.</returns>
            TResult Match<TResult>({{projections}});
            /// <summary>
            /// Creates a new instance of the union type using an instance of type <typeparamref name="T{{i}}"/>.
            /// </summary>
            /// <param name="value">The value from which to create an instance of <typeparamref name="TSelf"/>.</param>
            /// <returns>A new instance of <typeparamref name="TSelf"/>.</returns>
            static abstract TSelf Create(T{{i}} value);
        }
        """;
    _ = result.Append(definition);
}

var source = result.ToString();
var formattedSource = CSharpSyntaxTree.ParseText(source)
            .GetRoot()
            .NormalizeWhitespace()
            .SyntaxTree
            .GetText()
            .ToString();

File.WriteAllText("../../../../RhoMicro.Unions/Abstractions/Interfaces.cs", formattedSource);

static String ordinalOf(Int32 cardinal) => cardinal switch
{
    1 => "first",
    2 => "second",
    3 => "third",
    4 => "fourth",
    5 => "fifth",
    6 => "sixth",
    7 => "seventh",
    8 => "eigth",
    9 => "ninth",
    10 => "tenth",
    11 => "eleventh",
    12 => "twelfth",
    21 => "21st",
    22 => "22nd",
    23 => "22rd",
    31 => "31st",
    32 => "32nd",
    < 31 => $"{cardinal}th",
    _ => throw new ArgumentOutOfRangeException(nameof(cardinal), cardinal, $"{nameof(cardinal)} must be between 1 and 32 (inclusive).")
};
